{"version":3,"sources":["../../src/math.ts","../../src/components/SpinButton/SpinButton.types.ts","../../src/components/SpinButton/SpinButton.styles.ts","../../src/components/SpinButton/SpinButton.base.tsx","../../src/components/SpinButton/SpinButton.tsx","../../../../src/react/data/MutationData.ts","../../../../src/react/hooks/useMutation.ts"],"names":["precisionRound","value","precision","base","exp","Math","pow","round","KeyboardSpinDirection","getDisabledStyles","memoize","theme","semanticColors","SpinButtonTextColorDisabled","disabledText","SpinButtonBackgroundColorDisabled","disabledBackground","backgroundColor","pointerEvents","cursor","color","selectors","borderColor","getArrowButtonStyles","isUpArrow","customSpecificArrowStyles","palette","effects","ArrowButtonTextColor","neutralSecondary","ArrowButtonTextColorHovered","buttonText","ArrowButtonTextColorPressed","ArrowButtonBackgroundHovered","buttonBackgroundHovered","ArrowButtonBackgroundPressed","buttonBackgroundPressed","defaultArrowButtonStyles","root","outline","display","height","width","padding","textAlign","borderRadius","roundedCorner2","rootHovered","rootChecked","rootPressed","rootDisabled","opacity","icon","fontSize","marginTop","marginRight","marginBottom","marginLeft","getClassNames","classNamesFunction","DEFAULT_PROPS","disabled","label","step","labelPosition","start","incrementButtonIcon","iconName","decrementButtonIcon","noOp","clampValue","min","max","SpinButtonBase","propsWithoutDefaults","ref","props","getPropsWithDefaults","defaultValue","valueFromProps","precisionFromProps","iconProps","incrementButtonAriaLabel","decrementButtonAriaLabel","ariaLabel","ariaDescribedBy","customUpArrowButtonStyles","customDownArrowButtonStyles","ariaPositionInSet","ariaSetSize","ariaValueNow","ariaValueText","className","inputProps","onDecrement","onIncrement","iconButtonProps","onValidate","onChange","styles","input","inputId","useId","labelId","isFocused","setIsFocused","notSpinning","keyboardSpinDirection","setKeyboardSpinDirection","async","useAsync","groups","exec","String","length","calculatePrecision","useControllableValue","setValue","intermediateValue","setIntermediateValue","internalState","stepTimeoutHandle","latestValue","undefined","latestIntermediateValue","previousValueFromProps","usePrevious","classNames","nativeProps","validate","ev","enteredValue","newValue","trim","isNaN","Number","stop","clearTimeout","spinningByMouse","updateValue","stepFunction","persist","type","requestAnimationFrame","wasSpinning","setTimeout","handleIncrement","numericValue","handleDecrement","handleKeyUp","which","KeyCodes","up","down","handleIncrementMouseDown","handleDecrementMouseDown","componentRef","focus","current","useDebugWarnings","valueIsNumber","labelContent","labelWrapper","Icon","Label","id","htmlFor","bottom","spinButtonWrapper","onInput","target","autoComplete","role","onBlur","onFocus","select","onKeyDown","enter","preventDefault","stopPropagation","spinDirection","escape","onKeyUp","arrowButtonsContainer","IconButton","checked","onMouseDown","onMouseLeave","onMouseUp","tabIndex","displayName","SpinButton","styled","fonts","SpinButtonRootBorderColor","inputBorder","SpinButtonRootBackgroundColor","inputBackground","SpinButtonRootBorderColorHovered","inputBorderHovered","SpinButtonRootBorderColorFocused","inputFocusBorderAlt","SpinButtonInputTextColor","inputText","SpinButtonInputTextColorSelected","white","SpinButtonInputBackgroundColorSelected","inputBackgroundChecked","SpinButtonIconDisabledColor","medium","minWidth","alignItems","float","end","top","large","lineHeight","position","boxSizing","content","left","right","borderWidth","borderStyle","boxShadow","flex","margin","fontFamily","DEFAULT_MIN_WIDTH","whiteSpace","textOverflow","overflow","userSelect","scope","options","context","result","setResult","runMutation","mutationFunctionOptions","onMutationStart","mutationId","generateNewMutationId","mutate","then","response","onMutationCompleted","catch","error","onError","getOptions","onMutationError","data","errors","verifyDocumentType","mutation","Mutation","mostRecentMutationId","execute","this","isMounted","client","refreshClient","afterExecute","unmount","bind","cleanup","loading","ignoreResults","updateResult","called","onCompleted","graphQLErrors","isMostRecentMutation","previousResult","OperationData","useMutation","updatedOptions","mutationDataRef","mutationData","setOptions"],"mappings":"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","file":"static/js/9.a9ee5c83.chunk.js","sourcesContent":["import { Point } from './Point';\nimport { ISize } from './ISize';\n\n/**\n * Determines the distance between two points.\n *\n * @public\n */\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1: Point, point2: Point): number {\n  const left1 = point1.left || point1.x || 0;\n  const top1 = point1.top || point1.y || 0;\n  const left2 = point2.left || point2.x || 0;\n  const top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n\n  let distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n\n  return distance;\n}\n\n/**\n * The available fit modes. These should match the fit modes for CSS.\n */\nexport type FitMode = 'contain' | 'cover';\n\n/**\n * Options for fitting content sizes into bounding sizes.\n */\nexport interface IFitContentToBoundsOptions {\n  /**\n   * The size of the content to fit to the bounds.\n   * The output will be proportional to this value.\n   */\n  contentSize: ISize;\n  /**\n   * The size of the bounds.\n   */\n  boundsSize: ISize;\n  /**\n   * The fit mode to apply, either 'contain' or 'cover'.\n   */\n  mode: FitMode;\n  /**\n   * An optional maximum scale factor to apply. The default is 1.\n   * Use Infinity for an unbounded resize.\n   */\n  maxScale?: number;\n}\n\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\nexport function fitContentToBounds(options: IFitContentToBoundsOptions): ISize {\n  const { contentSize, boundsSize, mode = 'contain', maxScale = 1 } = options;\n\n  const contentAspectRatio = contentSize.width / contentSize.height;\n  const boundsAspectRatio = boundsSize.width / boundsSize.height;\n\n  let scale: number;\n\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n\n  const finalScale = Math.min(maxScale, scale);\n\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale,\n  };\n}\n\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\nexport function calculatePrecision(value: number | string): number {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  const groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n  if (!groups) {\n    return 0;\n  }\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n  if (groups[2]) {\n    return groups[2].length;\n  }\n  return 0;\n}\n\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\nexport function precisionRound(value: number, precision: number, base: number = 10): number {\n  const exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}\n","import * as React from 'react';\nimport { Position } from '../../Positioning';\nimport { IButtonStyles } from '../../Button';\nimport { IIconProps } from '../../Icon';\nimport { ITheme, IStyle } from '../../Styling';\nimport { IKeytipProps } from '../../Keytip';\nimport { IRefObject, IStyleFunctionOrObject } from '../../Utilities';\nimport { IButtonProps } from '../../Button';\n\n/**\n * {@docCategory SpinButton}\n */\nexport interface ISpinButton {\n  /**\n   * Current committed/validated value of the control. Note that this does *not* update on every\n   * keystroke while the user is editing text in the input field.\n   * \"committed\" the edit yet by focusing away (blurring) or pressing enter,\n   */\n  value?: string;\n\n  /**\n   * Sets focus to the control.\n   */\n  focus: () => void;\n}\n\n/**\n * {@docCategory SpinButton}\n */\nexport enum KeyboardSpinDirection {\n  down = -1,\n  notSpinning = 0,\n  up = 1,\n}\n\n/**\n * {@docCategory SpinButton}\n */\nexport interface ISpinButtonProps extends React.HTMLAttributes<HTMLDivElement>, React.RefAttributes<HTMLDivElement> {\n  /**\n   * Gets the component ref.\n   */\n  componentRef?: IRefObject<ISpinButton>;\n\n  /**\n   * Initial value of the control (assumed to be valid). Updates to this prop will not be respected.\n   *\n   * Use this if you intend for the SpinButton to be an uncontrolled component which maintains its\n   * own value. For a controlled component, use `value` instead. (Mutually exclusive with `value`.)\n   * @defaultvalue 0\n   */\n  defaultValue?: string;\n\n  /**\n   * Current value of the control (assumed to be valid).\n   *\n   * Only provide this if the SpinButton is a controlled component where you are maintaining its\n   * current state and passing updates based on change events; otherwise, use the `defaultValue`\n   * property. (Mutually exclusive with `defaultValue`.)\n   */\n  value?: string;\n\n  /**\n   * Min value of the control. If not provided, the control has no minimum value.\n   */\n  min?: number;\n\n  /**\n   * Max value of the control. If not provided, the control has no maximum value.\n   */\n  max?: number;\n\n  /**\n   * Difference between two adjacent values of the control.\n   * This value is used to calculate the precision of the input if no `precision` is given.\n   * The precision calculated this way will always be \\>= 0.\n   * @defaultvalue 1\n   */\n  step?: number;\n\n  /**\n   * A description of the control for the benefit of screen reader users.\n   */\n  ariaLabel?: string;\n\n  /**\n   * ID of a label which describes the control, if not using the default label.\n   */\n  ariaDescribedBy?: string;\n\n  /**\n   * A more descriptive title for the control, visible on its tooltip.\n   */\n  title?: string;\n\n  /**\n   * Whether or not the control is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * Custom className for the control.\n   */\n  className?: string;\n\n  /**\n   * Descriptive label for the control.\n   */\n  label?: string;\n\n  /**\n   * Where to position the control's label.\n   * @defaultvalue Left\n   */\n  labelPosition?: Position;\n\n  /**\n   * Props for an icon to display alongside the control's label.\n   */\n  iconProps?: IIconProps;\n\n  /**\n   * Callback for when the committed/validated value changes. This is called *after* `onIncrement`,\n   * `onDecrement`, or `onValidate`, on the following events:\n   * - User presses the up/down buttons (on single press or every spin)\n   * - User presses the up/down arrow keys (on single press or every spin)\n   * - User *commits* edits to the input text by focusing away (blurring) or pressing enter.\n   *   Note that this is NOT called for every key press while the user is editing.\n   */\n  onChange?: (event: React.SyntheticEvent<HTMLElement>, newValue?: string) => void;\n\n  /**\n   * Callback for when the entered value should be validated.\n   * @param value - The entered value to validate\n   * @param event - The event that triggered this validate, if any (for accessibility)\n   * @returns If a string is returned, it will be used as the new value\n   */\n  onValidate?: (value: string, event?: React.SyntheticEvent<HTMLElement>) => string | void;\n\n  /**\n   * Callback for when the increment button or up arrow key is pressed.\n   * @param value - The current value to be incremented\n   * @param event - The event that triggered this increment\n   * @returns If a string is returned, it will be used as the new value\n   */\n  onIncrement?: (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ) => string | void;\n\n  /**\n   * Callback for when the decrement button or down arrow key is pressed.\n   * @param value - The current value to be decremented\n   * @param event - The event that triggered this decrement\n   * @returns If a string is returned, it will be used as the new value\n   */\n  onDecrement?: (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ) => string | void;\n\n  /**\n   * Callback for when the user focuses the control.\n   */\n  onFocus?: React.FocusEventHandler<HTMLInputElement>;\n\n  /**\n   * Callback for when the control loses focus.\n   */\n  onBlur?: React.FocusEventHandler<HTMLInputElement>;\n\n  /**\n   * Custom props for the increment button.\n   */\n  incrementButtonIcon?: IIconProps;\n\n  /**\n   * Custom props for the decrement button.\n   */\n  decrementButtonIcon?: IIconProps;\n\n  /**\n   * Custom styling for individual elements within the control.\n   */\n  styles?: IStyleFunctionOrObject<ISpinButtonStyleProps, ISpinButtonStyles>;\n\n  /**\n   * Custom styles for the up arrow button.\n   *\n   * Note: The buttons are in a checked state when arrow keys are used to increment/decrement\n   * the SpinButton. Use `rootChecked` instead of `rootPressed` for styling when that is the case.\n   */\n  upArrowButtonStyles?: Partial<IButtonStyles>;\n\n  /**\n   * Custom styles for the down arrow button.\n   *\n   * Note: The buttons are in a checked state when arrow keys are used to increment/decrement\n   * the SpinButton. Use `rootChecked` instead of `rootPressed` for styling when that is the case.\n   */\n  downArrowButtonStyles?: Partial<IButtonStyles>;\n\n  /**\n   * Theme provided by HOC.\n   */\n  theme?: ITheme;\n\n  /**\n   * Accessible label text for the increment button (for screen reader users).\n   */\n  incrementButtonAriaLabel?: string;\n\n  /**\n   * Accessible label text for the decrement button (for screen reader users).\n   */\n  decrementButtonAriaLabel?: string;\n\n  /**\n   * How many decimal places the value should be rounded to.\n   *\n   * The default is calculated based on the precision of `step`: i.e. if step = 1, precision = 0.\n   * step = 0.0089, precision = 4. step = 300, precision = 2. step = 23.00, precision = 2.\n   */\n  precision?: number;\n\n  /**\n   * The position in the parent set (if in a set).\n   */\n  ariaPositionInSet?: number;\n\n  /**\n   * The total size of the parent set (if in a set).\n   */\n  ariaSetSize?: number;\n\n  /**\n   * Sets the control's aria-valuenow. This is the numeric form of `value`.\n   * Providing this only makes sense when using as a controlled component.\n   */\n  ariaValueNow?: number;\n\n  /*\n   * Sets the control's aria-valuetext.\n   * Providing this only makes sense when using as a controlled component.\n   */\n  ariaValueText?: string;\n\n  /**\n   * Keytip for the control.\n   */\n  keytipProps?: IKeytipProps;\n\n  /**\n   * Additional props for the input field.\n   */\n  inputProps?: React.InputHTMLAttributes<HTMLElement | HTMLInputElement>;\n\n  /**\n   * Additional props for the up and down arrow buttons.\n   */\n  iconButtonProps?: IButtonProps;\n}\n\n/**\n * {@docCategory SpinButton}\n */\nexport interface ISpinButtonStyles {\n  /**\n   * Styles for the root of the component.\n   */\n  root: IStyle;\n\n  /**\n   * Style for the label wrapper element, which contains the icon and label.\n   */\n  labelWrapper: IStyle;\n\n  /**\n   * Style for the icon.\n   */\n  icon: IStyle;\n\n  /**\n   * Style for the label text.\n   */\n  label: IStyle;\n\n  /**\n   * Style for the wrapper element of the input field and arrow buttons.\n   */\n  spinButtonWrapper: IStyle;\n\n  /**\n   * Styles for the input.\n   */\n  input: IStyle;\n\n  /**\n   * Styles for the arrowButtonsContainer\n   */\n  arrowButtonsContainer: IStyle;\n}\n\n/**\n * {@docCategory SpinButton}\n */\nexport interface ISpinButtonStyleProps {\n  theme: ITheme;\n  className: string | undefined;\n  disabled: boolean;\n  isFocused: boolean;\n  keyboardSpinDirection: KeyboardSpinDirection;\n  labelPosition: Position;\n}\n","import {\n  IRawStyle,\n  ITheme,\n  concatStyleSets,\n  HighContrastSelector,\n  IconFontSizes,\n  getInputFocusStyle,\n} from '../../Styling';\nimport { IButtonStyles } from '../../Button';\n\nimport { ISpinButtonStyles, ISpinButtonStyleProps } from './SpinButton.types';\nimport { memoizeFunction } from '../../Utilities';\nimport { Position } from '../../Positioning';\n\nconst ARROW_BUTTON_WIDTH = 23;\nconst ARROW_BUTTON_ICON_SIZE = 8;\nconst DEFAULT_HEIGHT = 32;\nconst DEFAULT_MIN_WIDTH = 86;\nconst LABEL_MARGIN = 10;\n\nconst getDisabledStyles = memoizeFunction(\n  (theme: ITheme): IRawStyle => {\n    const { semanticColors } = theme;\n\n    const SpinButtonTextColorDisabled = semanticColors.disabledText;\n    const SpinButtonBackgroundColorDisabled = semanticColors.disabledBackground;\n\n    return {\n      backgroundColor: SpinButtonBackgroundColorDisabled,\n      pointerEvents: 'none',\n      cursor: 'default',\n      color: SpinButtonTextColorDisabled,\n      selectors: {\n        ':after': {\n          borderColor: SpinButtonBackgroundColorDisabled,\n        },\n        [HighContrastSelector]: {\n          color: 'GrayText',\n        },\n      },\n    };\n  },\n);\n\nexport const getArrowButtonStyles = memoizeFunction(\n  (theme: ITheme, isUpArrow: boolean, customSpecificArrowStyles?: Partial<IButtonStyles>): IButtonStyles => {\n    const { palette, semanticColors, effects } = theme;\n\n    // TODO: after updating the semanticColor slots all this need to be reevaluated.\n    const ArrowButtonTextColor = palette.neutralSecondary;\n    const ArrowButtonTextColorHovered = semanticColors.buttonText;\n    const ArrowButtonTextColorPressed = semanticColors.buttonText;\n\n    const ArrowButtonBackgroundHovered = semanticColors.buttonBackgroundHovered;\n    const ArrowButtonBackgroundPressed = semanticColors.buttonBackgroundPressed;\n\n    const defaultArrowButtonStyles: IButtonStyles = {\n      root: {\n        outline: 'none',\n        display: 'block',\n        height: '50%',\n        width: ARROW_BUTTON_WIDTH,\n        padding: 0,\n        backgroundColor: 'transparent',\n        textAlign: 'center',\n        cursor: 'default',\n        color: ArrowButtonTextColor,\n        selectors: {\n          '&.ms-DownButton': {\n            borderRadius: `0 0 ${effects.roundedCorner2} 0`,\n          },\n          '&.ms-UpButton': {\n            borderRadius: `0 ${effects.roundedCorner2} 0 0`,\n          },\n        },\n      },\n      rootHovered: {\n        backgroundColor: ArrowButtonBackgroundHovered,\n        color: ArrowButtonTextColorHovered,\n      },\n      rootChecked: {\n        backgroundColor: ArrowButtonBackgroundPressed,\n        color: ArrowButtonTextColorPressed,\n        selectors: {\n          [HighContrastSelector]: {\n            backgroundColor: 'Highlight',\n            color: 'HighlightText',\n          },\n        },\n      },\n      rootPressed: {\n        backgroundColor: ArrowButtonBackgroundPressed,\n        color: ArrowButtonTextColorPressed,\n        selectors: {\n          [HighContrastSelector]: {\n            backgroundColor: 'Highlight',\n            color: 'HighlightText',\n          },\n        },\n      },\n      rootDisabled: {\n        opacity: 0.5,\n        selectors: {\n          [HighContrastSelector]: {\n            color: 'GrayText',\n            opacity: 1,\n          },\n        },\n      },\n      icon: {\n        fontSize: ARROW_BUTTON_ICON_SIZE,\n        marginTop: 0,\n        marginRight: 0,\n        marginBottom: 0,\n        marginLeft: 0,\n      },\n    };\n\n    // No specific styles needed as of now.\n    const defaultUpArrowButtonStyles: Partial<IButtonStyles> = {};\n\n    const defaultDownArrowButtonStyles: Partial<IButtonStyles> = {};\n\n    return concatStyleSets(\n      defaultArrowButtonStyles,\n      isUpArrow ? defaultUpArrowButtonStyles : defaultDownArrowButtonStyles,\n      customSpecificArrowStyles,\n    ) as IButtonStyles;\n  },\n);\n\nexport const getStyles = (props: ISpinButtonStyleProps): ISpinButtonStyles => {\n  const { theme, className, labelPosition, disabled, isFocused } = props;\n  const { palette, semanticColors, effects, fonts } = theme;\n  const SpinButtonRootBorderColor = semanticColors.inputBorder;\n  const SpinButtonRootBackgroundColor = semanticColors.inputBackground;\n  const SpinButtonRootBorderColorHovered = semanticColors.inputBorderHovered;\n  const SpinButtonRootBorderColorFocused = semanticColors.inputFocusBorderAlt;\n  const SpinButtonInputTextColor = semanticColors.inputText;\n  const SpinButtonInputTextColorSelected = palette.white;\n  const SpinButtonInputBackgroundColorSelected = semanticColors.inputBackgroundChecked;\n  const SpinButtonIconDisabledColor = semanticColors.disabledText;\n\n  return {\n    root: [\n      fonts.medium,\n      {\n        outline: 'none',\n        width: '100%',\n        minWidth: DEFAULT_MIN_WIDTH,\n      },\n      className,\n    ],\n\n    labelWrapper: [\n      {\n        display: 'inline-flex',\n        alignItems: 'center',\n      },\n      labelPosition === Position.start && {\n        height: DEFAULT_HEIGHT,\n        float: 'left',\n        marginRight: LABEL_MARGIN,\n      },\n      labelPosition === Position.end && {\n        height: DEFAULT_HEIGHT,\n        float: 'right',\n        marginLeft: LABEL_MARGIN,\n      },\n      labelPosition === Position.top && {\n        // Due to the lineHeight set on the label (below), the height of the wrapper (contains icon+label)\n        // ends up 1px taller than a standard label height, causing the vertical alignment to be off when\n        // the SpinButton is displayed with the label on top next to other form fields.\n        // Decrease the wrapper's effective height slightly to compensate.\n        marginBottom: -1,\n      },\n    ],\n\n    icon: [\n      {\n        padding: '0 5px',\n        fontSize: IconFontSizes.large,\n      },\n      disabled && {\n        color: SpinButtonIconDisabledColor,\n      },\n    ],\n\n    label: {\n      pointerEvents: 'none',\n      // centering the label with the icon by forcing the exact same height as the icon.\n      lineHeight: IconFontSizes.large,\n    },\n\n    spinButtonWrapper: [\n      {\n        display: 'flex',\n        position: 'relative',\n        boxSizing: 'border-box',\n        height: DEFAULT_HEIGHT,\n        minWidth: DEFAULT_MIN_WIDTH,\n        selectors: {\n          // setting border using pseudo-element here in order to prevent:\n          // input and chevron buttons to overlap border under certain resolutions\n          ':after': {\n            pointerEvents: 'none',\n            content: \"''\",\n            position: 'absolute',\n            left: 0,\n            top: 0,\n            bottom: 0,\n            right: 0,\n            borderWidth: '1px',\n            borderStyle: 'solid',\n            borderColor: SpinButtonRootBorderColor,\n            borderRadius: effects.roundedCorner2,\n          },\n        },\n      },\n      (labelPosition === Position.top || labelPosition === Position.bottom) && {\n        width: '100%',\n      },\n      !disabled && [\n        {\n          selectors: {\n            ':hover': {\n              selectors: {\n                ':after': {\n                  borderColor: SpinButtonRootBorderColorHovered,\n                },\n                [HighContrastSelector]: {\n                  selectors: {\n                    ':after': {\n                      borderColor: 'Highlight',\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n        isFocused && {\n          selectors: {\n            '&&': getInputFocusStyle(SpinButtonRootBorderColorFocused, effects.roundedCorner2),\n          },\n        },\n      ],\n      disabled && getDisabledStyles(theme),\n    ],\n\n    input: [\n      'ms-spinButton-input',\n      {\n        boxSizing: 'border-box',\n        boxShadow: 'none',\n        borderStyle: 'none',\n        flex: 1,\n        margin: 0,\n        fontSize: fonts.medium.fontSize,\n        fontFamily: 'inherit',\n        color: SpinButtonInputTextColor,\n        backgroundColor: SpinButtonRootBackgroundColor,\n        height: '100%',\n        padding: '0 8px 0 9px',\n        outline: 0,\n        display: 'block',\n        minWidth: DEFAULT_MIN_WIDTH - ARROW_BUTTON_WIDTH - 2,\n        whiteSpace: 'nowrap',\n        textOverflow: 'ellipsis',\n        overflow: 'hidden',\n        cursor: 'text',\n        userSelect: 'text',\n        borderRadius: `${effects.roundedCorner2} 0 0 ${effects.roundedCorner2}`,\n      },\n      !disabled && {\n        selectors: {\n          '::selection': {\n            backgroundColor: SpinButtonInputBackgroundColorSelected,\n            color: SpinButtonInputTextColorSelected,\n            selectors: {\n              [HighContrastSelector]: {\n                backgroundColor: 'Highlight',\n                borderColor: 'Highlight',\n                color: 'HighlightText',\n              },\n            },\n          },\n        },\n      },\n      disabled && getDisabledStyles(theme),\n    ],\n\n    arrowButtonsContainer: [\n      {\n        display: 'block',\n        height: '100%',\n        cursor: 'default',\n      },\n      disabled && getDisabledStyles(theme),\n    ],\n  };\n};\n","import * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport {\n  KeyCodes,\n  calculatePrecision,\n  classNamesFunction,\n  precisionRound,\n  getNativeProps,\n  getPropsWithDefaults,\n  divProperties,\n} from '../../Utilities';\nimport { getArrowButtonStyles } from './SpinButton.styles';\nimport { ISpinButtonProps, ISpinButtonStyleProps, ISpinButtonStyles, KeyboardSpinDirection } from './SpinButton.types';\nimport { Position } from '../../Positioning';\nimport { useAsync, useControllableValue, useWarnings, useId, usePrevious } from '@fluentui/react-hooks';\n\ninterface ISpinButtonInternalState {\n  spinningByMouse?: boolean;\n  stepTimeoutHandle: number;\n  /** Allows access to the latest `value` inside reused callbacks (to avoid stale capture issues) */\n  latestValue: string | undefined;\n  /** Allows access to the latest `intermediateValue` inside reused callbacks (to avoid stale capture issues) */\n  latestIntermediateValue: string | undefined;\n}\n\nconst getClassNames = classNamesFunction<ISpinButtonStyleProps, ISpinButtonStyles>();\n\nconst COMPONENT_NAME = 'SpinButton';\nconst DEFAULT_PROPS: Required<\n  Pick<\n    ISpinButtonProps,\n    // These are explicitly specified so that only the things which actually have defaults\n    // get marked as required in ISpinButtonPropsWithDefaults below\n    'disabled' | 'label' | 'step' | 'labelPosition' | 'incrementButtonIcon' | 'decrementButtonIcon'\n  >\n> = {\n  disabled: false,\n  label: '',\n  step: 1,\n  labelPosition: Position.start,\n  incrementButtonIcon: { iconName: 'ChevronUpSmall' },\n  decrementButtonIcon: { iconName: 'ChevronDownSmall' },\n};\ntype ISpinButtonPropsWithDefaults = ISpinButtonProps & typeof DEFAULT_PROPS;\n\nconst INITIAL_STEP_DELAY = 400;\nconst STEP_DELAY = 75;\n\nconst useComponentRef = (\n  props: ISpinButtonProps,\n  input: React.RefObject<HTMLDivElement>,\n  value: string | undefined,\n) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      get value() {\n        return value;\n      },\n      focus() {\n        if (input.current) {\n          input.current.focus();\n        }\n      },\n    }),\n    [input, value],\n  );\n};\n\nconst noOp = (): void => {\n  /**\n   * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n   * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n   * The no-op onChange handler was still needed because React gives console errors if an input\n   * doesn't have onChange.\n   *\n   * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n   * ours or 3rd-party, which simulate entering text in a SpinButton)\n   */\n};\n\n/** Clamp the value to the provided min and/or max */\nconst clampValue = (value: number, { min, max }: { max?: number; min?: number }) => {\n  if (typeof max === 'number') {\n    value = Math.min(value, max);\n  }\n  if (typeof min === 'number') {\n    value = Math.max(value, min);\n  }\n  return value;\n};\n\nexport const SpinButtonBase: React.FunctionComponent<ISpinButtonProps> = React.forwardRef<\n  HTMLDivElement,\n  ISpinButtonProps\n>((propsWithoutDefaults, ref) => {\n  const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults) as ISpinButtonPropsWithDefaults;\n  const {\n    disabled,\n    label,\n    min,\n    max,\n    step,\n    defaultValue,\n    value: valueFromProps,\n    precision: precisionFromProps,\n    labelPosition,\n    iconProps,\n    incrementButtonIcon,\n    incrementButtonAriaLabel,\n    decrementButtonIcon,\n    decrementButtonAriaLabel,\n    ariaLabel,\n    ariaDescribedBy,\n    upArrowButtonStyles: customUpArrowButtonStyles,\n    downArrowButtonStyles: customDownArrowButtonStyles,\n    theme,\n    ariaPositionInSet,\n    ariaSetSize,\n    ariaValueNow,\n    ariaValueText,\n    className,\n    inputProps,\n    onDecrement,\n    onIncrement,\n    iconButtonProps,\n    onValidate,\n    onChange,\n    styles,\n  } = props;\n\n  const input = React.useRef<HTMLInputElement>(null);\n  const inputId = useId('input');\n  const labelId = useId('Label');\n\n  const [isFocused, setIsFocused] = React.useState(false);\n  const [keyboardSpinDirection, setKeyboardSpinDirection] = React.useState(KeyboardSpinDirection.notSpinning);\n  const async = useAsync();\n\n  const precision = React.useMemo(() => {\n    return precisionFromProps ?? Math.max(calculatePrecision(step), 0);\n  }, [precisionFromProps, step]);\n\n  /**\n   * Actual current value. If `props.value` is provided (controlled), it will always be used.\n   * If not (uncontrolled), this tracks the current value based on user modifications.\n   * Note that while the user is editing text in the field, this will not be updated until \"commit\"\n   * (blur or press enter).\n   */\n  const [value, setValue] = useControllableValue(valueFromProps, defaultValue ?? String(min || 0), onChange);\n  /**\n   * \"Uncommitted\" internal value while the user is editing text in the field. This lets us wait to\n   * call `onChange` (and possibly update the real value) until the user \"commits\" the value by\n   * pressing enter or blurring the field.\n   */\n  const [intermediateValue, setIntermediateValue] = React.useState<string>();\n\n  const { current: internalState } = React.useRef<ISpinButtonInternalState>({\n    stepTimeoutHandle: -1,\n    latestValue: undefined,\n    latestIntermediateValue: undefined,\n  });\n  // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n  internalState.latestValue = value;\n  internalState.latestIntermediateValue = intermediateValue;\n\n  const previousValueFromProps = usePrevious(valueFromProps);\n  React.useEffect(() => {\n    // If props.value changes while editing, clear the intermediate value\n    if (valueFromProps !== previousValueFromProps && intermediateValue !== undefined) {\n      setIntermediateValue(undefined);\n    }\n  }, [valueFromProps, previousValueFromProps, intermediateValue]);\n\n  const classNames = getClassNames(styles, {\n    theme: theme!,\n    disabled,\n    isFocused,\n    keyboardSpinDirection,\n    labelPosition,\n    className,\n  });\n\n  const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties, [\n    'onBlur',\n    'onFocus',\n    'className',\n    'onChange',\n  ]);\n\n  /** Validate (commit) function called on blur or enter keypress. */\n  const validate = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLElement>): void => {\n      // Only run validation if the value changed\n      const enteredValue = internalState.latestIntermediateValue;\n      if (enteredValue !== undefined && enteredValue !== internalState.latestValue) {\n        let newValue: string | undefined;\n        if (onValidate) {\n          newValue = onValidate(enteredValue, ev) as string | undefined;\n        } else if (enteredValue && enteredValue.trim().length && !isNaN(Number(enteredValue))) {\n          // default validation handling\n          newValue = String(clampValue(Number(enteredValue), { min, max }));\n        }\n        if (newValue !== undefined && newValue !== internalState.latestValue) {\n          // Commit the value if it changed\n          setValue(newValue, ev);\n        }\n      }\n\n      // Done validating, so clear the intermediate typed value (if any)\n      setIntermediateValue(undefined);\n    },\n    [internalState, max, min, onValidate, setValue],\n  );\n\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n  const stop = React.useCallback((): void => {\n    if (internalState.stepTimeoutHandle >= 0) {\n      async.clearTimeout(internalState.stepTimeoutHandle);\n      internalState.stepTimeoutHandle = -1;\n    }\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      internalState.spinningByMouse = false;\n      setKeyboardSpinDirection(KeyboardSpinDirection.notSpinning);\n    }\n  }, [internalState, keyboardSpinDirection, async]);\n\n  /**\n   * Update the value with the given stepFunction.\n   * Also starts spinning for mousedown events by scheduling another update with setTimeout.\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n  const updateValue = React.useCallback(\n    (\n      stepFunction: Required<ISpinButtonProps>['onIncrement'],\n      ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLInputElement>,\n    ): void => {\n      ev.persist();\n\n      if (internalState.latestIntermediateValue !== undefined) {\n        // Edge case: if intermediateValue is set, this means that the user was editing the input\n        // text and then started spinning (either with mouse or keyboard). We need to validate and\n        // call onChange before starting to spin.\n        if (ev.type === 'keydown') {\n          // For the arrow keys, we have to manually trigger validation.\n          // (For the buttons, validation will happen automatically since the input's onBlur will\n          // be triggered after mousedown on the button completes.)\n          validate(ev);\n        }\n        async.requestAnimationFrame(() => {\n          // After handling any value updates, do the spinning update\n          updateValue(stepFunction, ev);\n        });\n        return;\n      }\n\n      // Call the step function and update the value.\n      // (Note: we access the latest value via internalState (not directly) to ensure we don't use\n      // a stale captured value. This is mainly important for spinning by mouse, where we trigger\n      // additional calls to the original updateValue function via setTimeout. It also lets us\n      // avoid useCallback deps on frequently changing values.)\n      const newValue = stepFunction(internalState.latestValue || '', ev) as string | undefined;\n      if (newValue !== undefined && newValue !== internalState.latestValue) {\n        setValue(newValue, ev);\n      }\n\n      // Schedule the next spin if applicable\n      // (will be canceled if there's a mouseup before the timeout runs)\n      const wasSpinning = internalState.spinningByMouse;\n      internalState.spinningByMouse = ev.type === 'mousedown';\n      if (internalState.spinningByMouse) {\n        internalState.stepTimeoutHandle = async.setTimeout(\n          () => {\n            updateValue(stepFunction, ev);\n          },\n          wasSpinning ? STEP_DELAY : INITIAL_STEP_DELAY, // the first step is slower\n        );\n      }\n    },\n    [internalState, async, validate, setValue],\n  );\n\n  /** Composed increment handler (uses `props.onIncrement` or default) */\n  const handleIncrement = React.useCallback(\n    (newValue: string): string | void => {\n      if (onIncrement) {\n        return onIncrement(newValue);\n      } else {\n        let numericValue = clampValue(Number(newValue) + Number(step), { max });\n        numericValue = precisionRound(numericValue, precision);\n        return String(numericValue);\n      }\n    },\n    [precision, max, onIncrement, step],\n  );\n\n  /** Composed decrement handler (uses `props.onDecrement` or default) */\n  const handleDecrement = React.useCallback(\n    (newValue: string): string | void => {\n      if (onDecrement) {\n        return onDecrement(newValue);\n      } else {\n        let numericValue = clampValue(Number(newValue) - Number(step), { min });\n        numericValue = precisionRound(numericValue, precision);\n        return String(numericValue);\n      }\n    },\n    [precision, min, onDecrement, step],\n  );\n\n  /** Handles when the user types in the input */\n  const handleInputChange = (ev: React.FormEvent<HTMLInputElement>): void => {\n    setIntermediateValue((ev.target as HTMLInputElement).value);\n  };\n\n  /** Composed focus handler (does internal stuff and calls `props.onFocus`) */\n  const handleFocus = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    // We can't set focus on a non-existing element\n    if (!input.current) {\n      return;\n    }\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      stop();\n    }\n    input.current.select();\n    setIsFocused(true);\n    props.onFocus?.(ev);\n  };\n\n  /** Composed blur handler (does internal stuff and calls `props.onBlur`) */\n  const handleBlur = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    validate(ev);\n    setIsFocused(false);\n    props.onBlur?.(ev);\n  };\n\n  /** Update value when arrow keys are pressed, commit on enter, or revert on escape */\n  const handleKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>): void => {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.enter) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n    if (disabled) {\n      stop();\n      return;\n    }\n\n    let spinDirection = KeyboardSpinDirection.notSpinning;\n\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        updateValue(handleIncrement, ev);\n        break;\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        updateValue(handleDecrement, ev);\n        break;\n      case KeyCodes.enter:\n        // Commit the edited value\n        validate(ev);\n        break;\n      case KeyCodes.escape:\n        // Revert to previous value\n        setIntermediateValue(undefined);\n        break;\n    }\n    // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n    if (keyboardSpinDirection !== spinDirection) {\n      setKeyboardSpinDirection(spinDirection);\n    }\n  };\n\n  /** Stop spinning on keyUp if the up or down arrow key fired this event */\n  const handleKeyUp = React.useCallback(\n    (ev: React.KeyboardEvent<HTMLElement>): void => {\n      // eslint-disable-next-line deprecation/deprecation\n      if (disabled || ev.which === KeyCodes.up || ev.which === KeyCodes.down) {\n        stop();\n        return;\n      }\n    },\n    [disabled, stop],\n  );\n\n  const handleIncrementMouseDown = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>): void => {\n      updateValue(handleIncrement, ev);\n    },\n    [handleIncrement, updateValue],\n  );\n\n  const handleDecrementMouseDown = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>): void => {\n      updateValue(handleDecrement, ev);\n    },\n    [handleDecrement, updateValue],\n  );\n\n  useComponentRef(props, input, value);\n  useDebugWarnings(props);\n\n  const valueIsNumber = !!value && !isNaN(Number(value)); // Number('') is 0 which may not be desirable\n\n  const labelContent = (iconProps || label) && (\n    <div className={classNames.labelWrapper}>\n      {iconProps && <Icon {...iconProps} className={classNames.icon} aria-hidden=\"true\" />}\n      {label && (\n        <Label id={labelId} htmlFor={inputId} className={classNames.label} disabled={disabled}>\n          {label}\n        </Label>\n      )}\n    </div>\n  );\n\n  return (\n    <div className={classNames.root} ref={ref}>\n      {labelPosition !== Position.bottom && labelContent}\n      <div\n        {...nativeProps}\n        className={classNames.spinButtonWrapper}\n        aria-label={ariaLabel && ariaLabel}\n        aria-posinset={ariaPositionInSet}\n        aria-setsize={ariaSetSize}\n        data-ktp-target={true}\n      >\n        <input\n          // Display intermediateValue while editing the text (before commit)\n          value={intermediateValue ?? value}\n          id={inputId}\n          onChange={noOp}\n          onInput={handleInputChange}\n          className={classNames.input}\n          type=\"text\"\n          autoComplete=\"off\"\n          role=\"spinbutton\"\n          aria-labelledby={label && labelId}\n          // TODO: test what happens while editing\n          aria-valuenow={ariaValueNow ?? (valueIsNumber ? Number(value) : undefined)}\n          aria-valuetext={ariaValueText ?? (valueIsNumber ? undefined : value)}\n          aria-valuemin={min}\n          aria-valuemax={max}\n          aria-describedby={ariaDescribedBy}\n          onBlur={handleBlur}\n          ref={input}\n          onFocus={handleFocus}\n          onKeyDown={handleKeyDown}\n          onKeyUp={handleKeyUp}\n          disabled={disabled}\n          aria-disabled={disabled}\n          data-lpignore\n          data-ktp-execute-target={true}\n          {...inputProps}\n        />\n        <span className={classNames.arrowButtonsContainer}>\n          <IconButton\n            styles={getArrowButtonStyles(theme!, true, customUpArrowButtonStyles)}\n            className={'ms-UpButton'}\n            checked={keyboardSpinDirection === KeyboardSpinDirection.up}\n            disabled={disabled}\n            iconProps={incrementButtonIcon}\n            onMouseDown={handleIncrementMouseDown}\n            onMouseLeave={stop}\n            onMouseUp={stop}\n            tabIndex={-1}\n            ariaLabel={incrementButtonAriaLabel}\n            data-is-focusable={false}\n            {...iconButtonProps}\n          />\n          <IconButton\n            styles={getArrowButtonStyles(theme!, false, customDownArrowButtonStyles)}\n            className={'ms-DownButton'}\n            checked={keyboardSpinDirection === KeyboardSpinDirection.down}\n            disabled={disabled}\n            iconProps={decrementButtonIcon}\n            onMouseDown={handleDecrementMouseDown}\n            onMouseLeave={stop}\n            onMouseUp={stop}\n            tabIndex={-1}\n            ariaLabel={decrementButtonAriaLabel}\n            data-is-focusable={false}\n            {...iconButtonProps}\n          />\n        </span>\n      </div>\n      {labelPosition === Position.bottom && labelContent}\n    </div>\n  );\n});\nSpinButtonBase.displayName = COMPONENT_NAME;\n\nconst useDebugWarnings = (props: ISpinButtonProps) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      mutuallyExclusive: { value: 'defaultValue' },\n    });\n  }\n};\n","import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { ISpinButtonProps, ISpinButtonStyles } from './SpinButton.types';\nimport { SpinButtonBase } from './SpinButton.base';\nimport { getStyles } from './SpinButton.styles';\n\n/**\n * The SpinButton control and related tabs pattern are used for navigating frequently accessed,\n * distinct content categories. SpinButtons allow for navigation between two or more content\n * views and relies on text headers to articulate the different sections of content.\n */\nexport const SpinButton: React.FunctionComponent<ISpinButtonProps> = styled<ISpinButtonProps, {}, ISpinButtonStyles>(\n  SpinButtonBase,\n  getStyles,\n  undefined,\n  {\n    scope: 'SpinButton',\n  },\n);\n","import { equal } from '@wry/equality';\n\nimport { DocumentType } from '../parser';\nimport { ApolloError } from '../../errors';\nimport {\n  MutationDataOptions,\n  MutationTuple,\n  MutationFunctionOptions,\n  MutationResult,\n} from '../types/types';\nimport { OperationData } from './OperationData';\nimport { MutationOptions, mergeOptions, ApolloCache, OperationVariables, DefaultContext } from '../../core';\nimport { FetchResult } from '../../link/core';\n\ntype MutationResultWithoutClient<TData = any> = Omit<MutationResult<TData>, 'client'>;\n\nexport class MutationData<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n> extends OperationData<MutationDataOptions<TData, TVariables, TContext, TCache>> {\n  private mostRecentMutationId: number;\n  private result: MutationResultWithoutClient<TData>;\n  private previousResult?: MutationResultWithoutClient<TData>;\n  private setResult: (result: MutationResultWithoutClient<TData>) => any;\n\n  constructor({\n    options,\n    context,\n    result,\n    setResult\n  }: {\n    options: MutationDataOptions<TData, TVariables, TContext, TCache>;\n    context: any;\n    result: MutationResultWithoutClient<TData>;\n    setResult: (result: MutationResultWithoutClient<TData>) => any;\n  }) {\n    super(options, context);\n    this.verifyDocumentType(options.mutation, DocumentType.Mutation);\n    this.result = result;\n    this.setResult = setResult;\n    this.mostRecentMutationId = 0;\n  }\n\n  public execute(result: MutationResultWithoutClient<TData>): MutationTuple<TData, TVariables, TContext, TCache> {\n    this.isMounted = true;\n    this.verifyDocumentType(this.getOptions().mutation, DocumentType.Mutation);\n    return [\n      this.runMutation,\n      { ...result, client: this.refreshClient().client }\n    ] as MutationTuple<TData, TVariables, TContext, TCache>;\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    // No cleanup required.\n  }\n\n  private runMutation = (\n    mutationFunctionOptions: MutationFunctionOptions<\n      TData,\n      TVariables,\n      TContext,\n      TCache\n    > = {} as MutationFunctionOptions<TData, TVariables, TContext, TCache>\n  ) => {\n    this.onMutationStart();\n    const mutationId = this.generateNewMutationId();\n\n    return this.mutate(mutationFunctionOptions)\n      .then((response: FetchResult<TData>) => {\n        this.onMutationCompleted(response, mutationId);\n        return response;\n      })\n      .catch((error: ApolloError) => {\n        const { onError } = this.getOptions();\n        this.onMutationError(error, mutationId);\n        if (onError) {\n          onError(error);\n          return {\n            data: undefined,\n            errors: error,\n          };\n        } else {\n          throw error;\n        }\n      });\n  };\n\n  private mutate(\n    options: MutationFunctionOptions<TData, TVariables, TContext, TCache>\n  ) {\n    return this.refreshClient().client.mutate(\n      mergeOptions(\n        this.getOptions(),\n        options as MutationOptions<TData, TVariables, TContext>,\n      ),\n    );\n  }\n\n  private onMutationStart() {\n    if (!this.result.loading && !this.getOptions().ignoreResults) {\n      this.updateResult({\n        loading: true,\n        error: undefined,\n        data: undefined,\n        called: true\n      });\n    }\n  }\n\n  private onMutationCompleted(\n    response: FetchResult<TData>,\n    mutationId: number\n  ) {\n    const { onCompleted, ignoreResults } = this.getOptions();\n\n    const { data, errors } = response;\n    const error =\n      errors && errors.length > 0\n        ? new ApolloError({ graphQLErrors: errors })\n        : undefined;\n\n    const callOncomplete = () =>\n      onCompleted ? onCompleted(data as TData) : null;\n\n    if (this.isMostRecentMutation(mutationId) && !ignoreResults) {\n      this.updateResult({\n        called: true,\n        loading: false,\n        data,\n        error\n      });\n    }\n    callOncomplete();\n  }\n\n  private onMutationError(error: ApolloError, mutationId: number) {\n    if (this.isMostRecentMutation(mutationId)) {\n      this.updateResult({\n        loading: false,\n        error,\n        data: undefined,\n        called: true\n      });\n    }\n  }\n\n  private generateNewMutationId(): number {\n    return ++this.mostRecentMutationId;\n  }\n\n  private isMostRecentMutation(mutationId: number) {\n    return this.mostRecentMutationId === mutationId;\n  }\n\n  private updateResult(result: MutationResultWithoutClient<TData>): MutationResultWithoutClient<TData> | undefined {\n    if (\n      this.isMounted &&\n      (!this.previousResult || !equal(this.previousResult, result))\n    ) {\n      this.setResult(result);\n      this.previousResult = result;\n      return result;\n    }\n  }\n}\n","import { useContext, useState, useRef, useEffect } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport { MutationHookOptions, MutationTuple } from '../types/types';\nimport { MutationData } from '../data';\nimport { ApolloCache, DefaultContext, OperationVariables } from '../../core';\nimport { getApolloContext } from '../context';\n\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<TData, TVariables, TContext>\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const context = useContext(getApolloContext());\n  const [result, setResult] = useState({ called: false, loading: false });\n  const updatedOptions = options ? { ...options, mutation } : { mutation };\n\n  const mutationDataRef = useRef<MutationData<TData, TVariables, TContext>>();\n  function getMutationDataRef() {\n    if (!mutationDataRef.current) {\n      mutationDataRef.current = new MutationData<TData, TVariables, TContext>({\n        options: updatedOptions,\n        context,\n        result,\n        setResult\n      });\n    }\n    return mutationDataRef.current;\n  }\n\n  const mutationData = getMutationDataRef();\n  mutationData.setOptions(updatedOptions);\n  mutationData.context = context;\n\n  useEffect(() => mutationData.afterExecute());\n\n  return mutationData.execute(result);\n}\n"],"sourceRoot":""}